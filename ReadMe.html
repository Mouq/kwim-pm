<h1 class="title">
kwim
</h1>
<p>Know What I Mean?!</p>
<h1>Description</h1>
<p>Kwim is a plain text markup language that converts to many formats:</p>
<ul>
<li>HTML
<ul>
<li>Rich - Lots of classes and annotations</li>
<li>Sparse - Just the tags and content</li>
<li>Custom - HTML the way </li>
</ul>
</li>
<li>Manpage</li>
<li>DocBook</li>
<li>MarkDown
<ul>
<li>GitHub Flavored</li>
</ul>
</li>
<li>Pod</li>
<li>AsciiDoc</li>
<li>MediaWiki</li>
</ul>
<p>The Kwim framework is easily extensible, so adding new outputs is easy.</p>
<h2>What Makes Kwim Different</h2>
<p>There are already a lot of text-to-html languages in the world. How is Kwim different?</p>
<p>Here are a few points:</p>
<ul>
<li>Very rich capabilities:
<p>Kwim aims to be a feature superset of the other markups since it converts to all of them.</p>
<p>Most of the other markups don&#39;t support things like multiple paragraphs in a bullet point (like you are reading right now!).</p>
</li>
</ul>
<ul>
<li>Simple, consistent markup:
<p>Even though Kwim intends to be very rich, it will use a simple set of syntax idioms to accomplish its tasks. One of my favorite sayings comes from Larry Wall of Perl fame: &quot;Make simple things simple and hard things possible&quot;. Kwim does just that (hopefully without looking too much like Perl ;).</p>
</li>
</ul>
<ul>
<li>Extensible:
<p>Kwim is easy to extend at many levels. You can add new backend formats. You can also define your own markup syntaxes. You can even define sections that parse using a different syntax grammar. For instance, you could inline a markdown section like this:</p>
<pre>.markdown This is [Markdown](http://daringfireball.net/projects/markdown/) text. :markdown
</pre>
</li>
</ul>
<ul>
<li>Multiple Implementations:
<p>Kwim is written using the Pegex parser framework. This provides 2 very powerful concepts. Firstly, that Kwim language is defined in a very simple PEG topdown grammar. That means it is easy to grok, maintain and extend. Second, Pegex parsers work in many languages. That means that you can use Pegex natively in languages like Ruby, JavaScript, Perl, Python and many others.</p>
</li>
</ul>
<ul>
<li>Comments and blank lines:
<p>Most markups don&#39;t support comments and eat extra blank lines. These things are useful. Kwim not only supports comments, they are part of the data model. ie They get rendered as HTML (or comments in other target languages that support comments). Kwim also support throwaway comments, for times when you want to hide part of a document.</p>
</li>
</ul>
<h2>Syntax Concepts</h2>
<p>Before diving into the actual markup syntax, let&#39;s discuss the concepts that drive the decisions that Kwim makes.</p>
<p>Most documents are just plain language using letters and numbers and a few punctuation chars like comma, dash, apostrophe, parentheses and colon. Also endings: period, exclamation point and question mark. We leave those alone (at least in the normal prose context).</p>
<p>This leaves a bunch of punctuation characters that we can do special things with. Namely: <code>@#$%^&amp;*=+|/~[]&lt;&gt;&#123;&#125;</code>. Sometimes context matters. For instance it is very rare for a prose line to start with a period, so we can use that as a markup.</p>
<p>The important thing in all this is that we be able to reverse the meaning for edge cases. ie We need a way to make markup characters be viewed as regular characters. Kwim uses a backslash before a character to make it not be seen as markup. For instance this text &quot;*not bold*&quot; is not bold because it was written like this: <code>&quot;\*not bold\*&quot;</code>.</p>
<p>Kwim has a document model that views things as <strong>blocks</strong> and <strong>phrases</strong>. This is very similar to HTML&#39;s <strong>DIV</strong> and <strong>SPAN</strong> concepts. Kwim views a document as a sequence of top level blocks. Blocks are further subdivided into either a sequence of blocks or a sequence of phrases. Phrases can only be subdivided into more phrases.</p>
<p>Consider this example document:</p>
<pre>A paragraph *is* a block. It gets divided into phrases like &#39;pure text&#39; and bold text. A bold phrase can be divided: *all bold /some italic/*.  * Lists are blocks. * Each item is a block.   + A sublist is a block.   + The text within in contains *phrases*.
</pre>
<p>Common blocks and phrases have an implicit (DWIM) syntax, that reads very natural. For instance a paragraph is just left justified text that is terminated by a blank line. There is also an explicit syntax for blocks and phrases. Every implicit syntax can be written explicitly. For instance, here is an implicit syntax example followed by its explicit equivalent:</p>
<pre>A paragraph with some *bold text* in it.  .para A paragraph with some &#123;bold: bold text&#125; in it. :para
</pre>
<h3>Two Space Indent</h3>
<p>Kwim uses a 2 space indentation and it is very instrumental to its design. It allows for a very nice and natural embedding of blocks within blocks. Consider this list:</p>
<pre>* Point one has   text on 2 lines   + Subpoint a * Point two    A paragraph for point 2 followed by some preformatted text:     # Code example * Point three
</pre>
<p>As you can see, 2 space indent is very natural here and allows for putting blocks inside blocks in a way that is not available in most markups.</p>
<h2>Kwim Syntax</h2>
<p>There are 4 sets of syntax to define: block <em> implicit, phrase </em> implicit, block <em> explicit and phrase </em> explicit. There are also escaping mechanisms.</p>
<h3>Block / Implicit Syntaxes</h3>
<p>A paragraph is a set of contiguous set of plain text lines. It is terminated by a blank line or by another block syntax at that level.</p>
<p>.side-by-side (pre Kwim) This is a paragraph of a few lines. As you can see, the newlines are not considered hard in HTML.</p>
<p>Another paragraph. (kwim HTML) This is a paragraph of a few lines. As you can see, the newlines are not considered hard in HTML.</p>
<p>Another paragraph. :side-by-side</p>
